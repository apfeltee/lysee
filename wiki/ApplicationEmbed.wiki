#labels Phase-Implementation
#Embed lysee to application step by step.

= Embed Lysee Step By Step =

This page will lead you create a expression evaluating application called _*calc.lpi*_ with embeded lysee to implement its evaluating capability.

== 1. Create Project _calc.lpi_ ==

  # Open lazarus and create a _*Application*_ project.
  # Save this project as _*calc.lpi*_.
  # Name main form as 'CalcForm' and save as _*frmcalc.pas*_.
  # Place a label editor on CalcForm and rename it as _*eExpr*_.
  # Place a label editor on CalcForm and rename is as _*eResult*_.
  # Place a button on CalcForm and rename it as _*bCalc*_.
  
----
== 2. Add Lysee Kernel To Project ==

Add _*lseu.pas*_ and _*lse_kernel.pas*_ into this project.

{{{
program calc;

{$mode objfpc}{$H+}

uses
  {$IFDEF UNIX}{$IFDEF UseCThreads}
  cthreads,
  {$ENDIF}{$ENDIF}
  Interfaces, Forms,
  frmcalc, lseu, lse_kernel;

{$R *.res}

begin
  Application.Initialize;
  Application.CreateForm(TCalcForm, CalcForm);
  Application.Run;
end.
}}}

----
== 3. Use _lseu.pas_ And _lse_kernel.pas_ in _frmcalc_ ==

Add _*lseu*_, _*lse_kernel*_ into _*frmcalc*_'s uses clause:

{{{
unit frmcalc;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, ExtCtrls,
  Buttons, StdCtrls, lseu, lse_kernel;
}}}

----
== 4. Startup Lysee Kernel ==

Create _*`OnCreate`*_ event handler and call _*lse_startup*_ to initialize lysee kernel:

{{{
procedure TCalcForm.FormCreate(Sender: TObject);
begin
  lse_startup;
end;
}}}

----
== 5. Cleanup Lysee Kernel ==

Create _*`OnDestroy`*_ event handler and call _*lse_cleanup*_ to finalize lysee kernel.

{{{
procedure TCalcForm.FormDestroy(Sender: TObject);
begin
  lse_cleanup;
end;
}}}

----
== 6. Create TLseEngine Instance ==

6.1. Define _*FEngine: TLseEngine*_ in TCalcForm:

{{{
type

  { TCalcForm }

  TCalcForm = class(TForm)
    bCalc: TButton;
    eExpr: TLabeledEdit;
    eResult: TLabeledEdit;
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
  private
    FEngine: TLseEngine;
  end; 
}}}

6.2. Create engine in _*`FormCreate`*_:

{{{
procedure TCalcForm.FormCreate(Sender: TObject);
begin
  lse_startup;
  FEngine := TLseEngine.Create(nil);
end;
}}}

6.3. Destroy engine in _*`FormDestroy`*_:

{{{
procedure TCalcForm.FormDestroy(Sender: TObject);
begin
  FEngine.Free;
  lse_cleanup;
end;
}}}

----
== 7. Evaluate Expression In _eExpr_ ==

Create _*bCalc*_'s _*`OnClick`*_ event handler and evaluate expression in _*eExpr*_:

{{{
procedure TCalcForm.bCalcClick(Sender: TObject);
begin
  eResult.Text := '';
  if FEngine.ExecuteCode(eExpr.Text) then
    eResult.Text := FEngine.ResultText else
    ShowMessage(FEngine.ErrorMsg);
end;
}}}

Press F9 to run this program and type a expression(for example: 6 * 9) to evaluate.

----
== 8. Create '_calc_' Module ==

8.1. Define _*FCalcModule: KLiModule*_ in TCalcForm:

{{{
type

  { TCalcForm }

  TCalcForm = class(TForm)
    bCalc: TButton;
    eExpr: TLabeledEdit;
    eResult: TLabeledEdit;
    procedure bCalcClick(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
  private
    FEngine: TLseEngine;
    FCalcModule: KLiModule;
  end; 
}}}

8.2. Create And Load _*calc*_ Module:

{{{
procedure TCalcForm.FormCreate(Sender: TObject);
begin
  lse_startup;
  FEngine := TLseEngine.Create(nil);
  // create calc module
  FCalcModule := KLiModule.Create('calc', nil, mtBuiltin);
  // load calc module
  FEngine.ExecuteCode('load("calc")');
end;
}}}

----
== 9. Register Lysee Functions ==

9.1. Define lysee function _*triple*_ to calculate: x * x * x.

{{{
// triple:float(value:float)
procedure triple(const Param: PLseParam);cdecl;
var
  V: double;
begin
  with Param^ do
  begin
    V := lse_get_float(p_param[0]);
    lse_set_float(p_result, V * V * V);
  end;
end;
}}}

9.2. Register function _*triple*_ into _*calc*_ module:

{{{
procedure TCalcForm.FormCreate(Sender: TObject);
begin
  lse_startup;
  FEngine := TLseEngine.Create(nil);
  // create calc module
  FCalcModule := KLiModule.Create('calc', nil, mtBuiltin);
  // register function triple
  FCalcModule.SetupFunc(@triple, 'triple:float(value:float)', 'triple float values');
  // load calc module
  FEngine.ExecuteCode('load("calc")');
end;
}}}

Press F9 to run this program again and enter 'triple(10)' to evaluate, you should got 1000.

Now, you can repeat step 8..9 to register any amount of lysee modules and functions to extend _*calc*_'s evaluating cability.